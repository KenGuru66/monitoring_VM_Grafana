═══════════════════════════════════════════════════════════════════════════════
  БЫСТРЫЙ СТАРТ: ГЕНЕРАЦИЯ ФАЙЛОВ ДЛЯ PERFMONKEY
═══════════════════════════════════════════════════════════════════════════════

ФИНАЛЬНАЯ ВЕРСИЯ СКРИПТА: parse_1cpu_perfmonkey.R
ДАТА: 2025-10-13

═══════════════════════════════════════════════════════════════════════════════
ЧТО ДЕЛАЕТ СКРИПТ
═══════════════════════════════════════════════════════════════════════════════

✓ Автоматически извлекает Serial Number из имени файла
✓ Сортирует данные по времени (от меньшего к большему)
✓ Создает ОТДЕЛЬНЫЙ ФАЙЛ для КАЖДОГО контроллера (0A, 0B, и т.д.)
✓ Правильно нумерует строки (1, 2, 3, ...)
✓ Заменяет запятые в названиях метрик на подчеркивания
✓ Убирает все кавычки
✓ Формат: готов для загрузки в PerfMonkey

═══════════════════════════════════════════════════════════════════════════════
ИСПОЛЬЗОВАНИЕ (3 ПРОСТЫХ ШАГА)
═══════════════════════════════════════════════════════════════════════════════

ШАГ 1: Создать CSV из бинарных логов
─────────────────────────────────────────────────────────────────────────────

cd /data/projects/monitoring_VM_Grafana/Data2csv

python3 Huawei_perf_parser_v0.2_parallel.py \
  -i logs/Storage_History_Performance_Files.zip \
  -o output_test \
  --all-metrics

Результат: output_test/SERIALNUMBER.csv


ШАГ 2: Создать файл с данными Controller
─────────────────────────────────────────────────────────────────────────────

cd output_test
FILE="SERIALNUMBER.csv"  # Замените на реальное имя

echo "Resource;Metric;InstanceName;Value;Time;UnixTime" > ${FILE}_cpu_all
awk -F';' '$1 == "Controller"' ${FILE} >> ${FILE}_cpu_all


ШАГ 3: Запустить R скрипт
─────────────────────────────────────────────────────────────────────────────

Rscript ../../perfmonkey/R_script/parse_1cpu_perfmonkey.R ${FILE}_cpu_all

РЕЗУЛЬТАТ: Создаются файлы для КАЖДОГО контроллера!
  - SERIALNUMBER_0A_output.csv
  - SERIALNUMBER_0B_output.csv
  - и т.д.


═══════════════════════════════════════════════════════════════════════════════
ПРИМЕР С РЕАЛЬНЫМИ ДАННЫМИ
═══════════════════════════════════════════════════════════════════════════════

FILE="2102353TJWFSP3100020.csv"

# Создать файл с данными Controller
echo "Resource;Metric;InstanceName;Value;Time;UnixTime" > ${FILE}_cpu_all
awk -F';' '$1 == "Controller"' ${FILE} >> ${FILE}_cpu_all

# Запустить скрипт
Rscript ../../perfmonkey/R_script/parse_1cpu_perfmonkey.R ${FILE}_cpu_all

РЕЗУЛЬТАТ:
  ✓ 2102353TJWFSP3100020_0A_output.csv (2,055 строк)
  ✓ 2102353TJWFSP3100020_0B_output.csv (2,052 строки)


═══════════════════════════════════════════════════════════════════════════════
ВЫВОД СКРИПТА
═══════════════════════════════════════════════════════════════════════════════

Extracted Serial Number: 2102353TJWFSP3100020
Reading CSV file...
Sorting data by instance and time...
Cleaning metric names...
Found 103 metrics, 2 instances

Processing instance: 0A
  Instance 0A: 2055 timepoints

Processing instance: 0B
  Instance 0B: 2050 timepoints

Writing separate files for each instance...
  ✓ Instance 0A: 2102353TJWFSP3100020_0A_output.csv (2055 rows)
  ✓ Instance 0B: 2102353TJWFSP3100020_0B_output.csv (2052 rows)

=== SUCCESS! ===
Created 2 files:
  - 2102353TJWFSP3100020_0A_output.csv
  - 2102353TJWFSP3100020_0B_output.csv

Serial Number: 2102353TJWFSP3100020
Instances: 0A, 0B
Columns per file: 110 (7 service + 103 metrics)
File format: CSV without quotes, commas in metric names replaced with underscores
Each instance has its own file, sorted by time


═══════════════════════════════════════════════════════════════════════════════
ХАРАКТЕРИСТИКИ ВЫХОДНЫХ ФАЙЛОВ
═══════════════════════════════════════════════════════════════════════════════

КАЖДЫЙ ФАЙЛ СОДЕРЖИТ:
  ✓ Данные ОДНОГО контроллера (0A, 0B, и т.д.)
  ✓ Serial Number: извлечен автоматически из имени файла
  ✓ Время: отсортировано от меньшего к большему
  ✓ Строки: пронумерованы начиная с 1
  ✓ Формат: CSV без кавычек, разделитель - запятая

СЛУЖЕБНЫЕ КОЛОНКИ (7 штук):
  1. CPUPERF       - Метка типа данных
  2. #             - Порядковый номер строки
  3. BgnDateTime   - Время начала (MM/DD/YY HH:MM:SS)
  4. EndDateTime   - Время окончания (= BgnDateTime)
  5. Serial        - Серийный номер массива
  6. Slot          - Контроллер (0A, 0B, и т.д.)
  7. Type          - Тип (CPU)

МЕТРИКИ (103 колонки):
  - Запятые заменены: [0K,4K) → [0K_4K)
  - Символ ∞ заменен: [128K,+∞) → [128K_+8)

ПРИМЕР СТРОКИ:
  CPUPERF,1,09/11/25 00:05:00,09/11/25 00:05:00,2102353TJWFSP3100020,0A,CPU,81,62,40,...


═══════════════════════════════════════════════════════════════════════════════
ГОТОВЫЕ ФАЙЛЫ (ПРИМЕР)
═══════════════════════════════════════════════════════════════════════════════

📁 perfmonkey/Controller_0A_PERFMONKEY.csv
   Serial: 2102353TJWFSP3100020
   Slot: 0A
   Строк: 2,055
   Время: 09/11/25 00:05:00 → 09/12/25 10:19:00

📁 perfmonkey/Controller_0B_PERFMONKEY.csv
   Serial: 2102353TJWFSP3100020
   Slot: 0B
   Строк: 2,052
   Время: 09/11/25 00:06:00 → 09/12/25 10:18:00

ГОТОВЫ ДЛЯ ЗАГРУЗКИ В PERFMONKEY! ✓


═══════════════════════════════════════════════════════════════════════════════
ВАЖНЫЕ ЗАМЕЧАНИЯ
═══════════════════════════════════════════════════════════════════════════════

1. ВСЕГДА используйте точное совпадение типа ресурса:
   ✓ ПРАВИЛЬНО: awk '$1 == "Controller"'
   ✗ НЕПРАВИЛЬНО: grep "^Controller"
   (grep захватит Controller NFSV3, NFSV4, и т.д.)

2. КАЖДЫЙ контроллер создает СВОЙ файл
   - Если в массиве 2 контроллера (0A, 0B) → будет 2 файла
   - Если в массиве 4 контроллера (0A, 0B, 0C, 0D) → будет 4 файла

3. Serial Number извлекается АВТОМАТИЧЕСКИ
   - Паттерн: последовательность из 15+ цифр и заглавных букв
   - Пример: "2102353TJWFSP3100020.csv" → SN: "2102353TJWFSP3100020"
   - Если не удалось извлечь → используется "111111"

4. Временные точки РАЗНЫЕ для разных контроллеров
   - Это нормально! Контроллеры могут работать в разное время
   - Каждый контроллер обрабатывается независимо


═══════════════════════════════════════════════════════════════════════════════
ДРУГИЕ РЕСУРСЫ
═══════════════════════════════════════════════════════════════════════════════

Для других ресурсов используйте аналогичный подход:

HOST:
  echo "Resource;Metric;InstanceName;Value;Time;UnixTime" > ${FILE}_host_all
  awk -F';' '$1 == "Host"' ${FILE} >> ${FILE}_host_all

LUN:
  echo "Resource;Metric;InstanceName;Value;Time;UnixTime" > ${FILE}_lun_all
  awk -F';' '$1 == "LUN"' ${FILE} >> ${FILE}_lun_all

DISK:
  echo "Resource;Metric;InstanceName;Value;Time;UnixTime" > ${FILE}_disk_all
  awk -F';' '$1 == "Disk"' ${FILE} >> ${FILE}_disk_all

STORAGE POOL:
  echo "Resource;Metric;InstanceName;Value;Time;UnixTime" > ${FILE}_pool_all
  awk -F';' '$1 == "Storage Pool"' ${FILE} >> ${FILE}_pool_all

ETHERNET PORT:
  echo "Resource;Metric;InstanceName;Value;Time;UnixTime" > ${FILE}_ethport_all
  awk -F';' '$1 == "Ethernet Port"' ${FILE} >> ${FILE}_ethport_all

(Для других ресурсов нужно адаптировать R скрипты)


═══════════════════════════════════════════════════════════════════════════════
ФАЙЛЫ И ДОКУМЕНТАЦИЯ
═══════════════════════════════════════════════════════════════════════════════

СКРИПТЫ:
  📄 perfmonkey/R_script/parse_1cpu_perfmonkey.R  - Основной скрипт

ДОКУМЕНТАЦИЯ:
  📄 perfmonkey/QUICK_START.txt                   - Эта инструкция
  📄 perfmonkey/UPDATED_SCRIPT_INFO.txt           - Подробное описание
  📄 perfmonkey/PERFMONKEY_FORMAT_CHANGES.txt     - Изменения формата
  📄 Data2csv/output_test/ANALYSIS_REPORT.txt     - Анализ данных

ПРИМЕРЫ ГОТОВЫХ ФАЙЛОВ:
  📁 perfmonkey/Controller_0A_PERFMONKEY.csv
  📁 perfmonkey/Controller_0B_PERFMONKEY.csv


═══════════════════════════════════════════════════════════════════════════════
КОНЕЦ ИНСТРУКЦИИ
═══════════════════════════════════════════════════════════════════════════════

